#include "arduinoFFT.h"
 
#define SAMPLES 128             //Must be a power of 2
#define SAMPLING_FREQUENCY 1000 //Hz, must be less than 10000 due to ADC
#define SCL_INDEX 0x00
#define SCL_TIME 0x01
#define SCL_FREQUENCY 0x02
#define SCL_PLOT 0x03
#define SCL_MEL 0x04
//#define getbit(sfr,bit) (_SFR_BYTE(sfr) & _BV(bit))


#define FILTER_TAP_NUM 49
static int16_t filter_taps[FILTER_TAP_NUM] = {-1354,-961,-2219,1194,-1181,2961,-3721,3623,-5067,7103,-7596,8352,-11011,12757,-12825,14822,-18035,18153,-17947,21785,-23840,19951,-21146,33893,-9719,
  33893,-21146,19951,-23840,21785,-17947,18153,-18035,14822,-12825,12757,-11011,8352,-7596,7103,-5067,3623,-3721,2961,-1181,1194,-2219,-961,-1354};

int16_t data_input[FILTER_TAP_NUM];
int16_t output;
int32_t a;
char i;
 
arduinoFFT FFT = arduinoFFT();
 
unsigned int sampling_period_us;
unsigned long microseconds;
 
double vReal[SAMPLES];
double vImag[SAMPLES];
 
void setup() {
    Serial.begin(9600);
    TIMSK0 = 0; // turn off timer0 for lower jitter
  ADCSRA = 0xe5; // set the adc to free running mode
  ADMUX = 0x40; // use adc0
  DIDR0 = 0x01; // turn off the digital input for adc0
  ADCSRA |= (1<<ADIE);
  //pinMode(A1,OUTPUT);
    //sampling_period_us = round(1000000*(1.0/SAMPLING_FREQUENCY));
}
 
void loop() {
   while(1){
    cli();
    /*SAMPLING*/
    for (int i = 0 ; i < 256/2 ; i ++) { // save 128 samples
      while(!(ADCSRA & 0x10)); // wait for adc to be ready
      ADCSRA = 0xf5; // restart adc
      byte m = ADCL; // fetch adc data
      byte j = ADCH;
      int k = (j << 8) | m; // form into an int
      k -= 0x0200; // form into a signed int
      k <<= 6; // form into a 16b signed int
      vReal[i] = k; // put real data into even bins
      //vReal[i+1] = 0; // set odd bins to 0
      vImag[i] = 0;
      //vImag[i+1] = 0;
    }
    /*FFT*/
    //PrintVector(vReal, SAMPLES, SCL_TIME);  
    FFT.Windowing(vReal, SAMPLES, FFT_WIN_TYP_HAMMING, FFT_FORWARD);
    FFT.Compute(vReal, vImag, SAMPLES, FFT_FORWARD);
    FFT.ComplexToMagnitude(vReal, vImag, SAMPLES);
   /* for(int i=0; i<SAMPLES; i++)
    {
      vReal[i]=log10(vReal[i]);
      //float val = map(vReal[i], 0, 100, 0, 255);
      //analogWrite(A1,val);
      //Serial.println(val);
      //vReal[i]=1/vReal[i];
      }*/
      
      FFT.Compute(vReal, vImag, SAMPLES, FFT_REVERSE);
      // fonction de 
    //double peak = FFT.MajorPeak(vReal, SAMPLES, SAMPLING_FREQUENCY);
 
    /*PRINT RESULTS*/
    //Serial.println(peak);     //Print out what frequency is the most dominant.
    sei();
    /*for(int i=0; i<(SAMPLES); i++)
    {
        //View all these three lines in serial terminal to see which frequencies has which amplitudes
         
        //Serial.print((i * 1.0 * SAMPLING_FREQUENCY) / SAMPLES, 1);
        //Serial.print(" ");
        Serial.println(vReal[i],1);    //View only this line in serial plotter to visualize the bins
    }*/
 
    //delay(1000);  //Repeat the process every second OR:
    //while(1);       //Run code once
    for(int i=0; i<FILTER_TAP_NUM; i++)
    {
      data_input[i]=vReal[i];
      //Serial.print(data_input[i]);
      }
    //for(i=FILTER_TAP_NUM-2 ; i>=0 ; i--)
 //data_input[i+1] = data_input[i] ;
 // Output Filtred data
 for(i=0;i<FILTER_TAP_NUM;i++)
 {
  a=filter_taps[i]*data_input[i] ;
  //enlever les commentaires pour mettre le rÃ©sultat en 32 bits 
  //a=a>>15;
  //a=(uint16_t)a;
 output = output + a ;
 Serial.println(output);
 }
 //Serial.println(data_input[0]); 
 //Serial.println(output);
 }}

void PrintVector(double *vData, uint16_t bufferSize, uint8_t scaleType)
{
  for (uint16_t i = 0; i < bufferSize; i++)
  {
    double abscissa;
    /* Print abscissa value */
    switch (scaleType)
    {
      case SCL_INDEX:
        abscissa = (i * 1.0);
  break;
      case SCL_TIME:
        abscissa = ((i * 1.0) / 19200);
  break;
      case SCL_FREQUENCY:
        abscissa = ((i * 1.0 * 19200) / SAMPLES);
  break;
    case SCL_MEL:
        abscissa =2410*log10(((1.6e-3*i*19200)/SAMPLES)+1);
        Serial.println(vData[i],4);
        break;
    }
    Serial.print(abscissa, 6);
    if(scaleType==SCL_FREQUENCY)
      Serial.print("Hz");
      Serial.print(" ");
      vData[i] = map(vData[i], 0, 1023, 0, 1023); 
     Serial.println(vData[i], 4);
  }
  Serial.println();
}

ISR(ADC_vect){
    for (int i = 0 ; i < SAMPLES ; i += 1) { // save 128 samples   
      while(!(ADCSRA & 0x10)); // wait for adc to be ready
      ADCSRA = 0xf5; // restart adc
      byte m = ADCL; // fetch adc data
      byte j = ADCH;
      int k = (j << 8) | m; // form into an int
      k -= 0x0200; // form into a signed int
      k <<= 6; // form into a 16b signed int
      vReal[i] = k; // put real data into even bins
      vImag[i] = 0;
      }
}

/*int getADC()
{
//while (!getBit(ADCSRA, ADIF)) ; // wait for ADC
  int i = ADCL;
  int j= ADCH;
  int k = (j << 8) | i; // form into an int
  k -= 0x0200; // form into a signed int
  k <<= 6; // form into a 16b signed int
  k=map(k,-32767,32767, 0, 1023);
  bitSet(ADCSRA, ADIF); // clear the flag
  bitSet(ADCSRA, ADSC); // start ADC conversion

  return k;}*/